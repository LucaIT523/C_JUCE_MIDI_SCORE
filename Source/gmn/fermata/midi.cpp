/*
	midi2gmn Library
	Copyright (C) 1992 - 2012 Juergen F. Kilian


	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 3 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 */

/*------------------------------------------------------------------
|	filename : MIDI.CPP
|	author     : Juergen Kilian
|	date	  : 17.10.1996-98/06-2000, 2011
|	implementation of  TMIDIFILE
------------------------------------------------------------------*/

#include <iostream>
#include <sstream>
#include <stack>
#include <string.h>

#include "../lib_src/ini/ini.h" // for saveAtoX

#include "track.h"
#include "midi.h"
#include "funcs.h"

#include "liste.h"

#include "event.h"
#include "portable.h"

#include "meta_key.h"
#include "meta_tempo.h"

#include "../leanguido/lgsegment.h"
#include "import.h"

using namespace std;

//-------------------------------------------------------------------
void TMIDIFILE::initData()
{
	// global ptr variable for accessing recppq and rectempo from everywhere
		tickTiming = 1; // == 1 before timing change
		OK     = 1;
		Status = 0;
		cVoiceSlices = 0;
		name = "";


		// defaults
		Relduration  = 100;

		RecTempo      = -1;
		RecPPQ 	     = -1;
		EvTracks = NULL;
		ControlTrack = NULL;
		TrackCountI = 0;
		mCurControl = NULL;
		qLength = 0;
		mInifile = NULL;
		mGLNBuffer = NULL;
}
//! constructor
TMIDIFILE::TMIDIFILE( const char *na )
{
	initData();
	if( na ) 
		name = na;
	else
		OK = 0;
}// TMIDIFILE
TMIDIFILE::TMIDIFILE( std::string *buffer )
{
	initData();
	mGLNBuffer = buffer;
}// TMIDIFILE
//-------------------------------------------------------------------
TMIDIFILE::~TMIDIFILE( void )
{	
	if( mInifile != NULL )
		delete mInifile;
	DeleteTracks();
}
void TMIDIFILE::DeleteTracks( void )
{
	if( ControlTrack )
	{
		delete ControlTrack;
		ControlTrack = NULL;
	}
	TTRACK *temp = EvTracks;
	while( temp )
	{
		TTRACK *tempNext = temp->Next();
		delete temp;
		temp = tempNext;
	}
	//   TrackCountI = 0;
}

//-------------------------------------------------------------------
/*
Open
Open file and read header
result :
1 : ok
0 : error
*/
char TMIDIFILE::Open( FILE *log )
{
	unsigned char temp[5];
	temp[4] = 0;
	
	// write to log
	if( log )
	{
		fprintf( log, "%%This file was generated by MIDI2GMN.EXE %s.\n", getVersion().c_str());
		fprintf(log, "%%MIDI2GMN.EXE is written 1998-2004-2011 by Juergen Kilian \n");
		fprintf(log,"%%as part of the GUIDO toolbox\n");
		fprintf(log,"%%for more information on GUIDO Music Notation please visit\n");
		//	fprintf(log,"%%http://www.informatik.tu-darmstadt.de/AFS/CM/GUIDO\n\n");
		fprintf(log,"%%http://www.salieri.org/GUIDO or http://www.noteserver.org\n\n");
		fprintf( log, "%%Filename: %s\n", name.c_str() );
		fprintf( log, "%%begin<header>---------------\n");
	}
	
	if( getGmnPostfix( name.c_str() ) )
	{
		format = 10; // gmn file
		if( log )
		{
			fprintf(log, "%%Input file was a GUIDO file!\n");
		}
	}
	else if( mGLNBuffer != NULL )
	{
		format = 10; // gmn file
		if( log )
		{
			fprintf(log, "%%Input file was a GLN-buffer!\n");
		}

	}
	else
	{
		file = fopen(name.c_str(), "rb");
		if( !file )
		{
			OK = 0;
			return( OK );
		}
		fread(temp, 1, 4, file);		// read 'MThd'
		if( strcmp( (const char*)temp, "MThd" ) != 0 )
		{
			std::cout << "ERROR: %s is not a MIDI file!" << name << endl;
			OK = 0;
			return( OK );
		}
		fread(temp, 1, 4, file);	// 00 00 00 06 = Block length
		
		fread(temp, 1, 1, file);	// 1 Byte for fileformat
		fread(&format, 1, 1, file);
		std::cout << "Fileformat=smf" << format << endl;
		if( log )
			fprintf(log, "%%Fileformat=SMF%d\n", format );
		
		fread(temp, 1, 1, file);	// 1 Byte for number of tracks
		
		fread(temp, 1, 1, file); // TrackCount
		TrackCountI = *temp;
		if( format )
			cout << "#Tracks: 1+" << (TrackC() -1 ) << endl;
		if( log )
			fprintf(log, "%%%d Tracks\n", TrackC() );
		
		EvTracks = NULL;
		/*
		for( i = 0; i < 256; i++ )
		Track[i]		  = NULL;
		*/
		
		fread(temp, 1, 2, file);	// 2 Byte for ppq
		RecPPQ =  temp[0] * 256;
		RecPPQ +=  temp[1];
		cout << "PPQ: " <<RecPPQ << endl;
		if( log )
		{
			fprintf( log, "%%PPQ=%d\n", RecPPQ );
			fprintf( log, "%%end<header>-----------------\n");
		}
		//	PartsPerClick = RecPPQ;
		
	}
	return OK;
} // Open
//-------------------------------------------------------------------
/*
Read all tracks,
result
1 : ok
0 : error
- Tracks including events of different channels
will be splitted in different tracks including
events of only 1 channel, all split tracks get the
(same) track-number of the physical track
*/
char TMIDIFILE::Read(	FILE *log	 )
{
	if( !file && Type() < 4)
		return 0;
	if( log )
		fprintf( log, "{\n" );
	//	PartsPerClick = metrobeat;
	
	// is this the second call ?
	//	if( Track[0] )
	if( EvTracks || ControlTrack )
	{
		DeleteTracks();
	} // if
	
	
	// create control track == track0 -------------------
	if( ControlTrack )
		delete ControlTrack;
	ControlTrack = CreateNewTrack( 14 );	// 14 = Offset Track 0
	ControlTrack->SetTrackNumber( 0 );
	
	if( Type() == 10 ) // gmn file
	{
		// call gmn parser and fill tracks from leanGUIDO data
		lgSegment *segment = new lgSegment( new lgFactory() );
		int pErr = 1;
		if( name.length() > 0 )
		{
			string fname = string(name);
			pErr = segment->parseFile( fname ) ;
		}
		else if( mGLNBuffer != NULL)
		{
			fprintf(log, "parsing GLNBuffer");
			pErr = segment->parseBuffer( mGLNBuffer) ;
		}
		else
		{
			fprintf(log,"name and GLNBuffer not set ");
		}
		if( !pErr )
		{			
			// fill data
			int i = 1;	
			lgSequence *temp = segment->firstSequence();
			while( temp )
			{
				TTRACK *curTrack = CreateNewTrack(0);
				curTrack->fill( temp,
								ControlTrack,
								RecPPQ,
								RecTempo);
				if( RecPPQ > 0 ||
					RecTempo > 0 )
				{
					// this file contains gln information!!!
					
					format = 9;
				}
				curTrack->SetTrackNumber( i++ );
				addTrack( curTrack );
				
				temp = segment->nextSequence();
				if( log && EvTracks )
					fprintf( log, ",\n");
			} // for all seuqences
		} // if no parse error

		delete segment;
		file = NULL; // already closed by delete segment
		if( pErr)
			return 0; // error no success
		else
			return 1;	// success
	}
	else	 // MIDI input
	{		
		long tempPos = ControlTrack->Read_Header( file );		
		// create empty track chuncks- ---------------------------
		if( Type() == 0 )
		{
			// is this smf0? -> Track 0 == Control Events
			//						  Track n == Channel n Events, n = 1..16
			// create one track for each channel
			TrackCountI = 17; // track 0+1..16
			int i = 1;
			//		for( i = 1; i < TrackCount; i++ )
			TTRACK *tempTrack;
			while( i < TrackC() )
			{
				tempTrack = CreateNewTrack( 14 );	// 14 = Offset Track 0
				tempTrack->SetTrackNumber( 1 ); // all tracks : nr=1
				if( EvTracks ) // insert in list
					EvTracks->append( tempTrack );
				else
					EvTracks = tempTrack;
				i++; // next track
			}
			//		Track[17] = 0;	// guard
		}
		else // create single smf 1 track, other tracks will be created at reading
		{
			if( TrackC() > 1 )
			{
				// tempPos == end of track0+1
				EvTracks = CreateNewTrack( tempPos );
				EvTracks->SetTrackNumber( 1 );
			}
		}
		
		// SMF0->ReadTrack0
		int i = 1;
		TTRACK *tempTrack = EvTracks;		
		// read all track headers ----------------------------
		while( tempTrack )
		{
			//		tempPos = Track[i]->Read_Header( file );
			long tempPos = tempTrack->Read_Header( file );
			if( !tempPos )
			{
				OK = 0;
				return OK;
			}
			// exist more tracks?
			if( Type() > 0 &&  //SMF1
				(i+1) < TrackC())
			{
				TTRACK *newTrack = CreateNewTrack( -1 /* dummy Offset tempPos */ );
				newTrack->SetTrackNumber( i+1 );
				tempTrack->SetNext( newTrack );
			} // < TrackCount
			i++;
			tempTrack = tempTrack->Next();
		} // while TempTrack
		
		// read events --------------------------------------
		OK = 1;
		if( Type() == 1 )   // smf 1?
		{
			int channelSelect = 0;
			TTRACK *Track0 = ControlTrack; // Tempo Events
			ControlTrack->Read( file,
				Relduration,
				0, // tempoFlag
				log, // log file
				RecPPQ,
				Track0,
				0, // track#
				channelSelect, // all Channels
				this // midifile
				);
			
			if( log && EvTracks )
				fprintf( log, ",\n");
			i = 1;
			TTRACK *tempTrack = EvTracks;
			// read event tracks ----------------
			TTrackInfo TrackInfo;
			while( tempTrack )
			{			
				if( channelSelect == 0 )  // set new TrackInfo
				{
					TrackInfo = tempTrack->Read( file,
						Relduration,
						0, // tempoFlag
						log,
						RecPPQ,
						Track0,
						i, // track#
						channelSelect, // all Channels
						this );
				} // if channel select
				else // keep TrackInfo
				{
					tempTrack->Read( file,
						Relduration,
						0, // tempoFlag
						log,
						RecPPQ,
						Track0,
						i, // track#
						channelSelect, // all Channels
						this );
				} // else
				if( TrackInfo.channelCount  // unread Events
					)
				{					
					// search for next unread channel
					do
					{
						channelSelect++;
					} while( channelSelect < 17 &&
							TrackInfo.unreadEvents[channelSelect-1] == 0);
					
					// check for list end
					if( channelSelect<17 )
					{
						TrackCountI++;
						// create new track
						TTRACK *newTrack = CreateNewTrack( tempTrack->GetOffset() );
						// insert new Track
						tempTrack->Insert( newTrack );
					}
					else
						channelSelect = 0; // no new track, reset to all Channels
				} // if channel count
				else // next real Track
				{
					OK++;
					channelSelect = 0; // all Channels
					i++; // next track#
				}
				
				if( tempTrack->Next() && log ) // one more track
					fprintf( log, "," );
				if( log )
					fprintf( log, "%%End of track %d\n", i-1);
				tempTrack = tempTrack->Next();
			} // while tempTrack
		}  // if smf1
		else // Read smf0
		{
			//			OK += Track[0]->Read( file,
			ControlTrack->Read( file,
				Relduration,
				ONLY_CTRL,
				//										  log, RecPPQ,Track[0],0,
				log, RecPPQ,ControlTrack,
				0, // track nr
				-1, // allChannels
				this	);
			//			for( i = 1; i < TrackC(); i++ )
			if( log && EvTracks )
				fprintf( log, ",\n");
			
			i = 1;
			tempTrack = EvTracks;
			while( tempTrack )
			{
				// Read Events of one MIDIChannel
				tempTrack->Read( file,
					Relduration,
					NO_CTRL,
					log, RecPPQ,0,
					1, // track number
					i, // MIDIChannelfilter
					this);
				tempTrack = tempTrack->Next();
				i++;
			} // for all tracks
			
			// here: delete empty tracks
			TTRACK *prevTrack = NULL;
			tempTrack = EvTracks;
			while( tempTrack )
			{
				// if no events at this Channel, delete Track
				if( !tempTrack->FirstNoteObject(-1 /* all voices */) )
				{
					if( prevTrack )
					{
						// remove from list
						prevTrack->SetNext( tempTrack->Next() );
						delete tempTrack;
						tempTrack = prevTrack->Next();
					}
					else
					{
						// remove listhead
						EvTracks = tempTrack->Next();
						delete tempTrack;
						tempTrack = EvTracks;
					}
				}
				else // not an empty Track
				{
					prevTrack = tempTrack;
					tempTrack = tempTrack->Next();
				}
			} // while tempTrack
		} // else (== smf0)
		
		// EvTracks->Debug();
		// the first not in track[0] must be a setTempo event
		if( ControlTrack )
		{
			TMetaTempo *tempoNote = ControlTrack->FirstTempo();
			if(  tempoNote )
			{
				RecTempo = tempoNote->GetTempo();
			}
			else
			{
				RecTempo = DEFAULT_TEMPO;
			}			
		} // if ControlTrack
		else // no ControlTrack
		{
			RecTempo = DEFAULT_TEMPO;
		}
	} // if smf 0
	
	mDirty = 0;	
	if( log )
		fprintf( log, "}\n" );	
	return OK;
} // Read
//-------------------------------------------------------------------
char TMIDIFILE::Close( void )
{
	if( file )
		fclose( file );
	return 1;
} // Close
//-------------------------------------------------------------------
TTRACK *TMIDIFILE::CreateNewTrack( long offset )
{
	TTRACK *temp = new TTRACK( offset, this );
	return temp;
}
char TMIDIFILE::getAuftaktI() const
{
    return mAuftakt;
}

char TMIDIFILE::getCalcTempo() const
{
    return CalcTempo;
}

TTRACK *TMIDIFILE::getControlTrack() const
{
    return ControlTrack;
}

int TMIDIFILE::getCountIn() const
{
    return CountIn;
}

TMusicalObject *TMIDIFILE::getCurControl() const
{
    return mCurControl;
}

char TMIDIFILE::getCurrentTrack() const
{
    return CurrentTrack;
}

char TMIDIFILE::getDirty() const
{
    return mDirty;
}

TTRACK *TMIDIFILE::getEvTracks() const
{
    return EvTracks;
}

FILE *TMIDIFILE::getFile() const
{
    return file;
}

unsigned char TMIDIFILE::getFormat() const
{
    return format;
}

char TMIDIFILE::getMustReload() const
{
    return mMustReload;
}

string TMIDIFILE::getName() const
{
    return name;
}

int TMIDIFILE::getRecPPQ() const
{
    return RecPPQ;
}

int TMIDIFILE::getRecTempo() const
{
    return RecTempo;
}

int TMIDIFILE::getRelduration() const
{
    return Relduration;
}

unsigned char TMIDIFILE::getStatus() const
{
    return Status;
}

int TMIDIFILE::getTickTiming() const
{
    return tickTiming;
}

int TMIDIFILE::getTrackCountI() const
{
    return TrackCountI;
}

int TMIDIFILE::getVoiceSlices() const
{
    return cVoiceSlices;
}

void TMIDIFILE::setAuftaktI(char AuftaktI)
{
    this->mAuftakt = AuftaktI;
}

void TMIDIFILE::setCalcTempo(char CalcTempo)
{
    this->CalcTempo = CalcTempo;
}

void TMIDIFILE::setControlTrack(TTRACK *controlTrack)
{
	if( ControlTrack )
		delete ControlTrack;
    this->ControlTrack = controlTrack;
}

void TMIDIFILE::setCountIn(int CountIn)
{
    this->CountIn = CountIn;
}

void TMIDIFILE::setCurControl(TMusicalObject *curControl)
{
    this->mCurControl = curControl;
}

void TMIDIFILE::setCurrentTrack(char CurrentTrack)
{
    this->CurrentTrack = CurrentTrack;
}

void TMIDIFILE::setDirty(char Dirty)
{
    this->mDirty = Dirty;
}

void TMIDIFILE::setEvTracks(TTRACK *EvTracks)
{
    this->EvTracks = EvTracks;
}

void TMIDIFILE::setFile(FILE *file)
{
    this->file = file;
}

void TMIDIFILE::setFormat(unsigned char format)
{
    this->format = format;
}

void TMIDIFILE::setMustReload(char mustReload)
{
    this->mMustReload = mustReload;
}

void TMIDIFILE::setName(char *name)
{
    this->name = name;
}

void TMIDIFILE::setRecPPQ(int RecPPQ)
{
    this->RecPPQ = RecPPQ;
}

void TMIDIFILE::setRecTempo(int RecTempo)
{
    this->RecTempo = RecTempo;
}

void TMIDIFILE::setRelduration(int Relduration)
{
    this->Relduration = Relduration;
}

void TMIDIFILE::setStatus(unsigned char Status)
{
    this->Status = Status;
}

void TMIDIFILE::setTickTiming(int tickTiming)
{
    this->tickTiming = tickTiming;
}

void TMIDIFILE::setTrackCountI(int TrackCountI)
{
    this->TrackCountI = TrackCountI;
}

void TMIDIFILE::setVoiceSlices(int cVoiceSlices)
{
    this->cVoiceSlices = cVoiceSlices;
}

//-------------------------------------------------------------------
TTRACK *TMIDIFILE::GetTrack( int i )
{
	if( i == 0 )
		return ControlTrack;
	
	TTRACK *tempTrack = EvTracks;
	int j = 1;
	while( tempTrack &&
		j < i )
	{
		j++;
		tempTrack = tempTrack->Next();
	}
	if( i == j )
		//	if( i < TrackC() )
	{
		return tempTrack;
	}
	else
	{
		Printf("GetTrack::Illegal Tracknumber!\n");
		return 0;
	}
}

// return # of accidentals (-7 .. 0 .. +7 )
// todo check currentKey
int TMIDIFILE::currentKey( TAbsTime pos )
{
	if( !ControlTrack )
		return 0;
	
	//	TQuantizedObject *temp;
	TMetaKey *next = NULL;
	TMetaKey *current = dynamic_cast<TMetaKey *>(mCurControl);
	if( current &&
		current->GetAbsTime() <= pos )
	{
		next = MetaKey(current->GetNext(current->GetVoice() ));	
	}
	else // start at begin of track
		current = ControlTrack->FirstKey();
	if( current )
		next = MetaKey(current->GetNext(current->GetVoice() ));
	else
		next = NULL;
	while( next && 
		next->GetAbsTime() <= pos )
	{
		current = next;
		next = MetaKey(current->GetNext(current->GetVoice() ));
	}
	// current <= pos < next
	if( current )
		return current->nAccidentals();
	mCurControl = current;
	return 0; // nothing specified
}

// append track to EvTracks;
void TMIDIFILE::addTrack(TTRACK *ptr)
{
	
	ptr->SetNext(NULL);
	if( !EvTracks )
		EvTracks = ptr;
	else
	{
		TTRACK *curTrack = EvTracks;
		while( curTrack->Next() ) // search for end of list
		{
			curTrack = curTrack->Next();
		}
		curTrack->SetNext( ptr );
	}
	TrackCountI++;
}

char TMIDIFILE::readIni(TInifile * /*inif*/)
{
	return 1;
}



int  TMIDIFILE::Tempo( TAbsTime *absTime )		
{	

	if( !absTime ||
		!ControlTrack)
		return RecTempo; 

	if( ControlTrack )
	{
		return ControlTrack->GetTempo(*absTime);
	}
	return RecTempo;
};


/// return the length of a quarter (at RecTempo and RecPPQ) note in MS
double TMIDIFILE::quarterLengthMS()
{
	if( qLength > 0 )
		return qLength;

	{
		qLength = DTIMEtoMS(this->Ppq(),
				this->RecTempo,
				this->Ppq());
		return qLength;
	}
}
void TMIDIFILE::setIniFilename(const char* filename)
{
	mIniFilename = filename;
}

TInifile *TMIDIFILE::getInifile()
{
	if( mInifile == NULL )
	{
		if( mIniFilename == NULL )
		{
			ShowErrorMsg("Inifilename is null");
		}
		mInifile = new TInifile( mIniFilename);
	}
	return mInifile;
}

void TMIDIFILE::setInifile( TInifile *inifile)
{
	if( mInifile != NULL)
		delete mInifile;
	mInifile = inifile;

}

